# Strategy Pattern

> 알고리즘군을 정의하고 각각을 캡슐화하여 교환해서 사용할 수 있도록 만든다. 스트래티지를 활용하면 알고리즘을 사용하는 클라이언트와의 독립적으로 알고리즘을 변경할 수 있다.
> 

### 비유해보기

객체 지향을 활용하고 싶은 신입 개발자 유씨는 이번 오리 게임에 관련하여 오리를 만드는 임무를 부여받았다. 유씨는 긴 고민을 하다 오리를 추상화된 객체로 만들어 다양한 오리들을 구현할 수 있게 만들었다.

<img width="582" alt="스크린샷 2021-10-14 오후 6 13 39" src="https://user-images.githubusercontent.com/58363663/137288055-22a1d431-8c39-4806-b449-12315416cc34.png">


이렇게 구현한 신입사원 유씨는 '이제 새로운 기능이 들어오면 오리 클래스에 기능을 추가하면 되겠지? 난 천재야!'라고 생각했다. 

실제로 날아다녀야 하는 기능이 추가되었다. 유씨는 오리클레스에 날기() 기능을 추가하였다.

<img width="545" alt="스크린샷 2021-10-14 오후 6 15 09" src="https://user-images.githubusercontent.com/58363663/137288127-65f6c6a6-e308-44ed-ac9f-eca570c1546f.png">



기능을 추가하여 데모를 했더니 난리가 났다. '또치는 날아다니면 안되는데 왜 날아다니나요. 이게 게임입니까??'

아뿔사 개발자 유씨는 모든 오리들에게 날아다니는 기능을 추가해버렸다. 매번 오리가 추가될때마다 기능이 조금씩 다를텐데 어떻게 해야될까 고민하는 순간 선배 개발자가 '전략패턴을 사용해보겠어요?'라고 키워드를 남겨주었다.

이제부터 방금 상황을 코드로 구현해보며 전략패턴에 대해 이해해보자. 

### 전략 패턴

```java
abstract class Duck {
    void run() { System.out.println("달린다!"); }
    void jump() { System.out.println("점프한다!"); }
    void dance() { System.out.println("춤춘다!"); }
}

class DonaldDuck extends Duck {

}

class Tube extends Duck {

}

class Ddochi extends Duck {

}
```

이때 날기 기능을 어떻게 추가해야할까? 날아다니는 기능이 담겨있는 인터페이스를 하나 만들어주면 된다.

```java
interface FlyBehavior {
    void fly();
}

class FlyWithWings implements FlyBehavior {

    @Override
    public void fly() {
        System.out.println("날아다닌다!");
    }
}

class FlyNoWay implements FlyBehavior {

    @Override
    public void fly() {
        // 날지 않는다.
    }
}
```

이제 FlyBehavior 인터페이스를 오리의 필드로 넣어주자.

```java
abstract class Duck {
    FlyBehavior flyBehavior;

    public Duck(FlyBehavior flyBehavior) {
        this.flyBehavior = flyBehavior;
    }

    void run() { System.out.println("달린다!"); }
    void jump() { System.out.println("점프한다!"); }
    void dance() { System.out.println("춤춘다!"); }
		**void fly() { this.flyBehavior.fly(); }**
}
```

이제 오리가 생성될 때 날게 만들지 못 날게 만들지 정해줄 수 있다. 
setFlyBehavior()라는 메소드를 만들어서 날지 못한 상태에서도 다시 날아다니도록 쉽게 변경할 수도 있다.

<img width="814" alt="스크린샷 2021-10-14 오후 6 15 37" src="https://user-images.githubusercontent.com/58363663/137288319-71e5eea5-1501-4726-8e8b-49b9200897b7.png">



### 정리

전략패턴을 사용하면 기능에 대해 유연하게 대처가 가능하다 느겼고 정말 자주쓰이는 패턴같아 보여 잘 익혀두어야겠다.

---


# Observer Pattern
> 한 객체의 상태가 바뀌면 그 객체에 의존하는 다른 객체들한테 연락이 가고 자동으로 내용이 갱신되는 방식으로 일대다 의존성을 정의한다.
> 

알아두어야 할 키워드 : 느슨한 결합

### 🌱 비유해보기

유씨는 평소 개발만 공부하다보니 사회, 경제, 정치 등 여려 교양 지식을 습득하지 못 하고 있다. 길가다 우연히 신문을 파는 아저씨를 만나게 되어 신문을 구독하기로 마음먹었다. 매일 집 앞으로 새로운 내용의 신문이 도착한다. 물론 유씨말고도 다양한 구독자들이 존재한다. 

구독을 신청한 구독자들은 매일 바뀐 상태의 신문을 받는다!! 여기서 `**구독자 = 옵저버**`이다.

하지만 시간이 지나자 유씨는 신문마저 읽지 않았고 결국 구독을 취소하였다. 이 과정이 옵저버 패턴에서 일어나는 과정이다. 

필요에 따라 옵저버로 등록하여 상태가 변할때마다 알림을 받을 수 있고 원하면 옵저버에서 탈퇴할 수 있다.

### ☘️ 옵저버 패턴

개발자 유씨는 오리 게임 프로젝트를 잘 마무리하고 새로운 임무를 부여받았다. 그 임무는 기상청 데이터를 활용하여 온도가 바뀔때마다 여러 디스플레이가 각각의 화면으로 보여질 수 있도록 기능을 구현해야한다.

<img width="710" alt="스크린샷 2021-10-15 오전 1 11 43" src="https://user-images.githubusercontent.com/58363663/137431303-e4e6d848-0443-4892-ac43-fb589df7575c.png">


```java
class WeatherData {

    public double setTemperature() {
        // 기상청 데이터 가져오는 로직
        this.temperature = 19.1D;
    }

    public double setHumidity() {
        // 기상청 데이터 가져오는 로직
        return this.humidity = 80.0D;
    }

    public void measure() {
        // 유씨가 구현해야될 로직
    }
}
```

신입 개발자 유씨는 여러 고민을 해보며 다음과 같이 코드를 구현하였다.

```java
public void measure() {
    display1.update(temperature, humidity);
    display2.update(temperature, humidity);
    display3.update(temperature, humidity);
}
```

역시나 선배개발자가 와서 위 코드에 문제에 대해 이야기했다. '매번 디스플레이를 추가하거나 삭제할건가요? 좀 더 추상화시켜보세요! 힌트는 옵저버 패턴이에요.' 

본격적으로 옵저버 패턴을 다이어그램으로 쉽게 이해해보자.

![스크린샷 2021-10-15 오후 1 15 10](https://user-images.githubusercontent.com/58363663/137431393-996b9f0e-5b83-4c4c-95e8-53ddaf5a90c4.png)


Subject는 옵저버를 등록하고 삭제하고 상태가 변경되었을때 모든 옵저버들에게 알림을 보낼 기능을 가진다.

Observer는 단순히 update() 기능을 한다. 옵저버가 되려는 객체들은 모두 해당 인터페이스를 구현해야한다.

**WeatherData**는 **Subject**를 구현하고 **Display는 Observer** 로 구현할 것이다.

```java
public static void main(String[] args) {
    WeatherData weatherData = new WeatherData();
    weatherData.setHumidity(18.0D);      // 기상청에서 가져온다 가정
    weatherData.setTemperature(87.0D);   // 기상청에서 가져온다 가정

    Display display1 = **new Display1(weatherData);**
    Display display2 = **new Display2(weatherData);**

    weatherData.measure();

    weatherData.setHumidity(11.0D);      // 기상청에서 가져온다 가정
    weatherData.setTemperature(90.0D);   // 기상청에서 가져온다 가정

    weatherData.measure();
}
```

- 먼저 WeatherData 객체를 생성한 후 옵저버로 사용될 display1과 display2를 생성한다.
- 내부 로직을 더 살펴보면 알겠지만 이렇게 생성만해도 diplay1,2는 Observer 인터페이스를 구현한 구현체이므로 이제 온도나 습도가 바뀔때마다 measure() 메소드를 호출하면 display에서 화면이 나오게 될 것이다.
- 정리) display1과 display2는 WeatherDate를 구독하였고 상태가 변경될때마다 알림을 받을것이다.

```java
interface Subject {
    void registerObserver(Observer observer);    //옵저버 추가
    void removeObserver(Observer observer);      //옵저버 삭제
    void notifyObserver();
}

class WeatherData implements Subject {

    List<Observer> observerList = new ArrayList<>();
    double temperature;
    double humidity;

    public void setTemperature(double temperature) {
        this.temperature = temperature;
    }

    public void setHumidity(double humidity) {
        this.humidity = temperature;
    }

    public void measure() {
        notifyObserver();
    }

    @Override
    public void registerObserver(Observer observer) {
        observerList.add(observer);
    }

    @Override
    public void removeObserver(Observer observer) {
        observerList.remove(observer);
    }

    @Override
    public void notifyObserver() {
				**// 핵심!!!!! 옵저버들한테 상태 변경됐다고 전달**
        for (Observer observer : observerList) {
            **observer.update(temperature, humidity);**  
        }
    }
}
```

- WeatherDate는 여러 옵저버를 가질 수 있으므로 List로 가진다. (feat.신문 구독자들)
- measure() 혹은  notifyObserver()를 사용하면 모든 옵저버들에게 상태가 변경된 것을 알리게 된다.
- 정리) WeatherData는 여러 옵저버들을 관리한다!! (feat.신문사)

```java
interface Observer {
    void update(double temperature, double humidity);
}

interface Display {

    void display();
}

class Display1 implements Observer, Display {

    double temperature;
    double humidity;
    Subject weatherData;

    public Display1(Subject weatherData) {
        this.weatherData = weatherData;
        **weatherData.registerObserver(this);     // 저 구독할게요!!!**
    }

    @Override
    public void update(double temperature, double humidity) {
        this.temperature = temperature;
        this.humidity = humidity;
        display();
    }

    @Override
    public void display() {
				// Display1의 기능을 하도록 구현하자! 다형성!!!
        System.out.println("Display1 송출입니다. 온도 : " + temperature + " 습도 : " + humidity);
    }
}

class Display2 implements Observer, Display {

  // ...
}
```

- Display 인터페이스를 구현한 구현체들은 생성될때 Subject를 인자로 받아서 옵저버로 등록한다.

### 정리

전략패턴보다는 조금 난이도가 있을 수 있다고 생각한다. 하지만 신문사와 구독자를 잘 떠올리면 생각보다 쉽게 구현 될 것이다! 자바 라이브러리에 있는 Observer 인터페이스는 현재 Deprecated되었다.
